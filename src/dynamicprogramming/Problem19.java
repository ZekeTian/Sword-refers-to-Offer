package dynamicprogramming;

/**
 * https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/
 * 
 * 题目描述：请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。
 *        在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。
 * 
 * 限制条件：
 *  （1）s 可能为空，且只包含从 a-z 的小写字母。
 *  （2）p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。
 * 
 * 示例：
 *  示例 1
 *      输入:
 *          s = "aa"
 *          p = "a"
 *      输出: false
 *      解释: "a" 无法匹配 "aa" 整个字符串。
 *      
 *  示例 2
 *      输入:
 *          s = "aa"
 *          p = "a*"
 *      输出: true
 *      解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
 * 
 *  示例 3
 *      输入:
 *          s = "ab"
 *          p = ".*"
 *      输出: true
 *      解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
 *  
 *  示例 4
 *      输入:
 *          s = "aab"
 *          p = "c*a*b"
 *      输出: true
 *      解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
 */
public class Problem19 {

    public static void main(String[] args) {
//        String s = "aa", p = "a";
        
//        String s = "aa", p = "a*";
        
//        String s = "ab", p = ".*";

//        String s = "aab", p = "c*a*b";
        String s = "aaa", p = "ab*a*c*a";
        
        _19Solution solution = new _19Solution();
        
        
        System.out.println(solution.isMatch(s, p));
    }
}


/**
 * 动态规划思路：
 *  s：原字符串，p：正则表达式，memo[i][j] 表示 s[0...i-1]、p[0...j-1] 时的结果
 *  
 *  （1）当 p 的最后一个字符 p[n-1] = '.' 时，s 中最后一个字符 s[m-1] 可以与之匹配，所以 s、p 都要向前缩进一个字符，即转换成 s[0...m-2]、p[0...n-2]
 *  （2）当 p 的最后一个字符 p[n-1] 是普通字符时：
 *      1）如果 s 中最后一个字符 s[m-1] 可以与之匹配，则转换成 s[0...m-2]、p[0...n-2]
 *      2）如果 s 中最后一个字符 s[m-1] 不能与之匹配，则说明 s、p 不能匹配
 *  （3）当 p 的最后一个字符 p[n-1] = '*' 时，则表示 p[n-2] = c 可以匹配 0 次或多次，即 "c*"（p[n-2...n-1]） 要作为一个整体进行匹配：
 *      1）如果 s[m-1] 不是 c，则相当于 "c*" 匹配了 0 次，并且无法再继续匹配，所以 s、p 均要向前移动，转换成 s[0...m-1]、p[0...n-3]（因为 s 中没有 c，所以实际上 s 长度不变）
 *      2）如果 s[m-1] 是 c，则相当于 "c*" 匹配了 1 次，但是 p 中的 "c*" 可能还能继续匹配 s ，所以 p 不向前移动，但是 s 要向前移动，即转换成 s[0...m-2]、p[0...n-1]
 *        但是要注意的是，此时的 s[m-1] 可以选择与 p[n-2...n-1] 匹配，也可以选择不匹配。选择不匹配时，相当于匹配 0 次，和上面一种情况一样。
 *        所以此时，实际上是转换成 s[0...m-2]、p[0...n-1] （选择匹配） 或 s[0...m-1]、p[0...n-3] （选择不匹配）
 *        测试示例 String s = "aaa", p = "ab*a*c*a" 能够测试出这种情况。
 *        在计算状态 memo[1][5] 时，即 s = "a", p = "ab*a*"。因为 p[3...4] = "a*" 可以选择与 s[0] 匹配，也可以选择不匹配。
 *        如果只考虑匹配的情况，则 memo[1][5] = false；如果只考虑不匹配的情况，则 memo[1][5] = true。
 *        同时考虑，取“或”操作，memo[1][5] = true，可以使得最终结果正确。但是如果只考虑匹配的话，那么最终结果会错误，
 *      
 *  状态转移过程：
 *      对于 （1）、（2） 两种情况，可以统一成一种情况，即 memo[i][j] = memo[i - 1][j - 1]。
 *  因为情况 （2） 中的 2）是无法匹配，所以 memo[i][j] 应该直接设置为 false，但是默认值即为 false，所以无需对其进行处理。
 *      对于 （3）中的 1），memo[i][j] = memo[i][j - 2]，正则表达式匹配成功，但是不需要继续匹配
 *      对于 （3）中的 2），memo[i][j] = memo[i - 1][j]，正则表达式匹配成功，但是还需要继续匹配
 *      
 *  初始状态（原字符串 s 是空串）：
 *      原字符串 s 是空串时，则如下两种情况可以匹配到
 *      （1）p 是空串时
 *      （2）p 是 ".*"，这里的 '.' 可以是任意字符，如 '.' 表示 'a' 时，则是 'a*'。当然， '.' 也可以表示 '.'，则此时是 '.*'
 */
class _19Solution {
    
    public boolean isMatch(String s, String p) {
        if ("*".equals(p)) { // 限制正则表达式 p 中的 '*' 前面必须有一个字符，所以当 '*' 前面无字符时，则抛出异常
            throw new IllegalArgumentException("输入的正则表达式非法");
        }
        
        int m = s.length();
        int n = p.length();
        boolean[][] memo = new boolean[m + 1][n + 1]; // memo[i][j] 表示 s[0...i-1]、p[0...j-1] 时的结果
        
        memo[0][0] = true;
        for (int j = 2; j <= n; j += 2) { // 当 s 是空串，p = ".*" 时，也可以匹配成功（'.'可以是任意字符）。正是因为 ".*" 长度是 2，所以 j 自增的步长是 2
            if (p.charAt(j - 1) == '*') {
                // 因为 ".*" 可以匹配到空串，所以 p 应该向前移动两个字符。
                // 当匹配到时，s 本来也应该向前移动，但是因为 s 是空串，已经无法移动，所以依然保持 0。因此，最终转移到状态 memo[0][j - 2];
                memo[0][j] = memo[0][j - 2]; 
            }
        }
        
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                // p[j - 1] 是 '*'，一次需要考虑 p 中的两个字符，即同时考虑 p[j-2]、p[j-1]
                if (p.charAt(j - 1) == '*') { // 因为有 *，所以可以考虑不匹配（即匹配 0 次），即 s 的长度可以保持不变，即能够转移到 memo[i][j - 2]
                    // 因为限制正则表达式 p 中的 '*' 前面必须有一个字符，所以当 p[j - 1] = '*' 时，j - 1 >= 1，即 j - 2 >= 0，因此无需检查 j - 2 是否合法
                    if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) { // 能够与 s[i-1] 匹配，但是也可以选择不匹配
                        // 若 p 中的 ".*" 选择与 s[i-1] 匹配，则 s 长度减 1、 p 长度不变（因为是*，所以后面还可以继续匹配），即转移到状态 memo[i-1][j]
                        // 若 p 中的 ".*" 选择不与 s[i-1] 匹配，则 s 长度不减少、p 长度减 2（因为 ".*" 不再使用），即转移到状态 memo[i][j - 2]，相当于下面的 else（匹配 0 次）
                        memo[i][j] = (memo[i - 1][j] || memo[i][j - 2]); 
                    } else { // 一定不能与 s[i-1] 匹配
                        // p 中的 ".*" 能与 s 进行 0 次匹配（实际上就是匹配不到），并且无法继续匹配，所以 p 的长度减 2， s 的长度不变
                        memo[i][j] = memo[i][j - 2]; 
                    }
                    continue;
                }
                
                // p[j - 1] 是 '.' 或普通字符
                if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {
                    memo[i][j] = memo[i - 1][j - 1];
                } else {
                    memo[i][j] = false; // 匹配不上，则设置为 false。实际上，此处的 else 可以省略，因为默认值即为 false
                }
            }
        }

        return memo[m][n];
    }
}
